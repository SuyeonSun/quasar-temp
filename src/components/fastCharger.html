
<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=320' />
    <meta name='apple-mobile-web-app-capable' content='yes' />
    <title>Gauge panel basic</title>
    <script src='https://d3js.org/d3.v6.min.js'></script>
    <style>
    </style>
</head>
<body>
<div style="padding: 50px">

    <div id="chart" style="width: 330px;height: 300px;"></div>
</div>

<script>
    var width = 400;
    var height = 300; //this is the double because are showing just the half of the pie
    var radius = Math.min(width, height) / 2;


    var labelr = radius + 30; // radius for label anchor
    // array of colors for the pie (in the same order as the dataset)
    var color = ['#00adff', '#dbdbdb', '#f4f4f4']

    const dataFromServer = [
        { label: 'Ev', value: 60 }, // 24
        { label: 'Average', value: 300 }, // 47
        { label: 'Max', value: 780 }, // 60
    ]

    const data = [
        { label: 'Ev', value: 60 }, // 24
        { label: 'Average', value: 240 }, // 33
        { label: 'Max', value: 280 }, // 13
    ];

    // https://mygumi.tistory.com/346
    var vis = d3.select("#chart")
        .append("svg")              //create the SVG element inside the <body>
        .data([data])                   //associate our data with the document
        .attr("width", width)           //set the width and height of our visualization (these will be attributes of the <svg> tag
        .attr("height", height)
        // svg:g
        .append("svg:g")                //make a group to hold our pie chart
        .attr('transform', 'translate(' + (width / 2) +  ',' + (height / 2) + ')');    //move the center of the pie chart from 0, 0 to radius, radius

    var arc = d3.arc()              //this will create <path> elements for us using arc data
        .innerRadius(90)
        .outerRadius(radius - 10) // full height semi pie

    // TODO: 수정 필요
    var pie = d3.pie()           //this will create arc data for us given a list of values
        .startAngle(-90 * (Math.PI/180))
        .endAngle(90 * (Math.PI/180))
        .sort(null) //No! we don't want to order it by size
        .value(function(d) {
            const ev = dataFromServer[0].value
            const average = dataFromServer[1].value

            if (ev < average) {
                if (d.label === 'Average') {
                    return average-ev
                } else {
                    return d.value
                }
            } else {
                if (d.label === 'Average') {
                    return 0
                } else {
                    return d.value
                }
            }
        });


    var arcs = vis.selectAll("g.slice")     //this selects all <g> elements with class slice (there aren't any yet)
        .data(pie)  //associate the generated pie data (an array of arcs, each having startAngle, endAngle and value properties)
        .enter()   //this will create <g> elements for every "extra" data element that should be associated with a selection. The result is creating a <g> for every object in the data array
        .append("svg:g")  //create a group to hold each slice (we will have a <path> and a <text> element associated with each slice)
        .attr("class", "slice")    //allow us to style things in the slices (like text)

    // TODO: 전체 색상 채우기
    arcs.append("svg:path")
        .attr("fill", function(d, i) { return color[i]; } ) //set the color for each slice to be chosen from the color function defined above
        .attr("d", arc);                                    //this creates the actual SVG path using the associated data (pie) with the arc drawing function

    // TODO: 가운데 텍스트
    arcs.append('svg:text')
        .attr("text-anchor", "middle")
        .attr('font-size', '2em')
        .attr('fill', '#282828')
        // .attr('x', -20)
        .attr('y', -10)
        .text(function (d) {
            const evHourText = Math.floor(d.data.value / 60) === 0 ? '' : Math.floor(d.data.value / 60)+'h';
            const evMinText = Math.floor(d.data.value % 60) === 0 ? '' : Math.floor(d.data.value % 60)+'MIN';
            if(d.data.label === 'Ev') {
                return evHourText + evMinText
            }
        })

    // TODO: 평균 텍스트
    arcs.append("svg:text")
        .attr("class", "labels")//add a label to each slice
        .attr("fill", "#282828")
        .attr('transform', "translate(" + radius + ", " + -(radius - 30)  + ")") // 평균 label의 고정
        .text(function(d, i) {
            const avHourText = Math.floor(dataFromServer[1].value / 60) === 0 ? '' : Math.floor(dataFromServer[1].value / 60) + 'h'
            const avMinText = Math.floor(dataFromServer[1].value % 60) === 0 ? '' : Math.floor(dataFromServer[1].value % 60) + 'MIN'

            if (data[i].label === 'Average') {
                return avHourText + avMinText;
            }
        })

    // arcs.insert('rect','text').attr('x', function(d) {return })

    // TODO: Max 텍스트
    arcs.append("svg:text")
        .attr("class", "labels")//add a label to each slice
        .attr("fill", "black")
        .attr('transform', "translate(" + radius + ", 0)")
        .text(function(d, i) {
            const maxHourText = Math.floor(dataFromServer[2].value / 60) === 0 ? '' : Math.floor(dataFromServer[2].value / 60) + 'h'
            const maxMinText = Math.floor(dataFromServer[2].value % 60) === 0 ? '' : Math.floor(dataFromServer[2].value % 60) + 'MIN'
            if (data[i].label === 'Max') return maxHourText + maxMinText;
        })
</script>
</body>
</html>